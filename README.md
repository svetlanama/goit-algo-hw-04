
Програма `task3.py` порівнює три алгоритми сортування: сортування злиттям (Merge Sort), сортування вставками (Insertion Sort) та вбудований у Python алгоритм `sorted()` (який використовує Timsort) за часом виконання. Порівняння проводиться на різних наборах даних (випадкові, вже відсортовані та зворотньо відсортовані) різного розміру, використовуючи модуль `timeit` для заміру часу.

Метою є емпірична перевірка теоретичних оцінок складності алгоритмів та демонстрація ефективності Timsort.

### Використання

Скрипт не приймає аргументів командного рядка. Просто запустіть його:

```bash
python task3.py
```

### Емпіричні дані та висновки

Програма виводить таблицю з часом виконання кожного алгоритму для різних розмірів та типів даних. Нижче наведено приклад виводу з емпіричними даними:

```
Data Size      Data Type           Merge Sort (s)      Insertion Sort (s)  Timsort (s)         
-----------------------------------------------------------------------------------------------
100            Random              0.000086            0.000102            0.000005            
100            Sorted              0.000076            0.000006            0.000001            
100            Reverse Sorted      0.000075            0.000205            0.000001            
1000           Random              0.001076            0.009519            0.000056            
1000           Sorted              0.000672            0.000040            0.000004            
1000           Reverse Sorted      0.000667            0.015613            0.000016            
5000           Random              0.004794            0.213281            0.000352            
5000           Sorted              0.003811            0.000261            0.000029            
5000           Reverse Sorted      0.003819            0.420395            0.000074            
10000          Random              0.010055            0.854830            0.000768            
10000          Sorted              0.008059            0.000444            0.000067            
10000          Reverse Sorted      0.008323            1.718226            0.000231            
```

===============================================================================================
**Висновки:**
1. Timsort (вбудований `sorted()`) є найефективнішим алгоритмом сортування в більшості випадків, особливо для великих наборів даних та частково відсортованих масивів. Це підтверджує, що комбінація сортування злиттям та сортування вставками, а також оптимізації, роблять його дуже швидким.
2. Merge Sort показує стабільну продуктивність для різних типів даних, що відповідає його теоретичній складності O(N log N). Його ефективність є хорошою для великих масивів, але зазвичай повільнішою за Timsort через більші накладні витрати.
3. Insertion Sort є дуже ефективним для малих наборів даних або майже відсортованих даних. Однак, його продуктивність значно погіршується для великих і невпорядкованих наборів даних (O(N^2) в найгіршому випадку), що робить його непридатним для сортування великих масивів.
4. Емпіричні дані підтверджують теоретичні оцінки складності. Для великих масивів Timsort і Merge Sort значно перевершують Insertion Sort.
5. Отже, програмістам варто використовувати вбудовані функції сортування Python, оскільки вони реалізовані високоефективним Timsort-ом і оптимізовані для різних сценаріїв використання. 